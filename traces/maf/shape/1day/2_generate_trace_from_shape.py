# Takes in the request per second shape of the trace and generates a request
# trace from it using Poisson arrivals
import numpy as np
import pandas as pd


# The trace is generated by sampling a request ID in the range [1, MAX_REQUEST_ID]
# This request ID is appended to the request line in addition to the request time
# in order to identify different requests for request-aware or query-aware
# inference serving
MAX_REQUEST_ID = 5000

df = pd.read_csv('transformed_invocations.csv')
invocations = df['invocations'].values

trace = []
offset = 0
for hour in range(len(invocations)):
    requests = round(invocations[hour])
                    
    if requests == 0:
        raise Exception(f'No requests at hour: {hour}')
        continue

    # we need to distribute these requests around the entire second using the exponential
    # distribution for inter-arrival rates. In other words, the requests follow Poisson
    # arrival within the second
    arrivals = np.rint(np.random.exponential(scale=1000/requests,
                                             size=requests))
    # plt.hist(arrivals)
    # plt.savefig('exponential_arrivals.pdf')
    # plt.close()

    current = 0
    # print(arrivals)
    for time in arrivals:
        current += time
        if time < 1000:
            trace.append(offset + current)

    # at the end of the second, we increment the offset in milliseconds
    offset += 1000

with open('trace/trace.txt', mode='w') as wf:
    for arrival_time in trace:
        wf.write(str(arrival_time) + ',' + str(np.random.randint(1, MAX_REQUEST_ID)) + '\n')
